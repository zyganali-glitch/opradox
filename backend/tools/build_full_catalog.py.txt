# backend/tools/build_full_catalog.py
"""
opradox - Senaryo Kataloğu + (Opsiyonel) Mini Kullanım Kılavuzu Üretici

Bu script şunları yapar:
1) tools.scenario_source içindeki 'scenarios' listesini okur (senin uzun add(...) script'in).
2) Her senaryoyu, app/scenario_registry.py'nin beklediği formata çevirir:
   - id, category, title_tr/en, short_tr/en, tags, engine_hint, status, implementation
3) Mevcut engine'lere göre "implementation" bağlar (hangi senaryo hangi Python modülünü çağırıyor).
4) Sonuçları backend/config/scenarios_catalog.json dosyasına yazar.
5) İstersen --with-llm parametresi ile, her senaryo için:
   - Nedir? (what_is_tr)
   - Nasıl kullanılır? (how_to_tr maddeleri)
   - Örnek kullanımlar (examples_tr)
   alanlarını OpenAI üzerinden üretir ve katalog içine gömer.

Kullanım:
    cd backend

    # Sadece katalog üret (LLM çağrısı yok, $ harcanmaz):
    python -m tools.build_full_catalog

    # Katalog + mini kullanım kılavuzu (Nedir/Nasıl/Örnek) üret:
    python -m tools.build_full_catalog --with-llm

NOT:
- OpenAI API key'in ortam değişkeni olarak ayarlı olmalı:
    setx OPENAI_API_KEY "BURAYA_ANAHTAR"
- Küçük model için GM_LLM_SMALL_MODEL ayarlamazsan varsayılan: gpt-4.1-mini
"""

from __future__ import annotations

import argparse
import json
from pathlib import Path
from typing import Any, Dict, List

from . import llm_client
from . import scenario_source  # Senin uzun add(...) script'in bu modul


# Proje kökünü ve katalog yolunu belirle
ROOT_DIR = Path(__file__).resolve().parents[1]  # backend/
CONFIG_DIR = ROOT_DIR / "config"
CATALOG_PATH = CONFIG_DIR / "scenarios_catalog.json"

# Senin ham senaryo listeni al
RAW_SCENARIOS: List[Dict[str, Any]] = scenario_source.scenarios

# -------------
# 1) Engine -> Python modul eşlemesi
# -------------
# Burada amacımız:
# - Senin scenario_source içindeki engine_hint alanlarını,
# - app/scenarios içindeki gerçek Python dosyalarına bağlamak.
#
# Bu liste, elimizde olan engine'ler üzerinden "en güvenli" eşleştirmeleri içeriyor.
# Gerekirse ileride genişletebiliriz.
ENGINE_HINT_TO_IMPLEMENTATION: Dict[str, Dict[str, str]] = {
    # COUNT / FREKANS
    "count_rows": {"module": "app.scenarios.count_value", "func": "run"},          # tek sütunda belirli değeri say
    "count_rows_multi": {"module": "app.scenarios.count_rows_multi", "func": "run"},  # çoklu koşul
    "count_nonblank": {"module": "app.scenarios.count_value", "func": "run"},      # dolu hücre sayımı için aynı engine

    "frequency_table": {"module": "app.scenarios.frequency_table", "func": "run"},  # tek/multi kolon frekans

    # KOŞULLU TOPLAM / ORTALAMA
    "sum_if": {"module": "app.scenarios.sum_if", "func": "run"},
    "sum_ifs": {"module": "app.scenarios.sum_multi", "func": "run"},
    "avg_if": {"module": "app.scenarios.average_condition", "func": "run"},
    "avg_ifs": {"module": "app.scenarios.average_condition", "func": "run"},

    # TEMEL İSTATİSTİK
    "stats_basic": {"module": "app.scenarios.descriptive_stats", "func": "run"},

    # RAPORLAMA & PIVOT BENZERİ (tahmini eşleştirme)
    "report_group_summary": {"module": "app.scenarios.report_group_summary", "func": "run"},
    "report_multi_metric_summary": {"module": "app.scenarios.report_multi_metric_summary", "func": "run"},
    "report_filter_then_group": {"module": "app.scenarios.report_filter_then_group", "func": "run"},
    "report_pivot_matrix_sum": {"module": "app.scenarios.report_pivot_matrix_sum", "func": "run"},
    "report_pivot_matrix_count": {"module": "app.scenarios.report_pivot_matrix_count", "func": "run"},

    # POWER QUERY TARZI
    "pq_append_tables": {"module": "app.scenarios.pq_append_tables", "func": "run"},
    "dt_unpivot": {"module": "app.scenarios.pq_unpivot_columns", "func": "run"},
}

# Bazı senaryolarda engine_hint yerine doğrudan id üzerinden bağlamak isteyebiliriz.
ID_TO_IMPLEMENTATION: Dict[str, Dict[str, str]] = {
    # Mevcut frontend ile %100 uyumlu olanlar:
    "count-value": {"module": "app.scenarios.count_value", "func": "run"},
    "count-multi": {"module": "app.scenarios.count_rows_multi", "func": "run"},
    "count-rows-multi": {"module": "app.scenarios.count_rows_multi", "func": "run"},  # yeni id varyantı
    "sum-if": {"module": "app.scenarios.sum_if", "func": "run"},
    # İstersen buraya tek tek başka id'ler de ekleyebiliriz.
}


def build_base_catalog() -> List[Dict[str, Any]]:
    """
    scenario_source.scenarios içindeki ham kayıtları,
    scenario_registry'nin beklediği katalog formatına çevirir.
    """
    items: List[Dict[str, Any]] = []

    for raw in RAW_SCENARIOS:
        sid = raw["id"]
        category_id = raw.get("category_id")
        title_tr = raw.get("title_tr")
        title_en = raw.get("title_en")
        short_tr = raw.get("short_desc_tr")
        short_en = raw.get("short_desc_en")
        tags_tr = raw.get("tags_tr", [])
        tags_en = raw.get("tags_en", [])
        engine_hint = raw.get("engine_hint")

        # 1) Temel meta
        entry: Dict[str, Any] = {
            "id": sid,
            "category": category_id,  # scenario_registry list_scenarios bunu "category" olarak döndürüyor
            "title_tr": title_tr,
            "title_en": title_en,
            "short_tr": short_tr,
            "short_en": short_en,
            # Arama için hem TR hem EN tag'leri tut
            "tags": tags_tr,       # scenario_registry list_scenarios -> "tags"
            "tags_tr": tags_tr,
            "tags_en": tags_en,
            "engine_hint": engine_hint,
        }

        # 2) Implementation / runner eşlemesi
        impl: Dict[str, Any] | None = None

        # Önce ID bazlı eşleşme
        if sid in ID_TO_IMPLEMENTATION:
            base_impl = ID_TO_IMPLEMENTATION[sid]
            impl = {**base_impl, "status": "implemented"}

        # Sonra engine_hint bazlı eşleşme
        elif engine_hint and engine_hint in ENGINE_HINT_TO_IMPLEMENTATION:
            base_impl = ENGINE_HINT_TO_IMPLEMENTATION[engine_hint]
            impl = {**base_impl, "status": "implemented"}

        # Hiçbiri yoksa: henüz yazılmamış / bağlanmamış senaryo
        if impl is None:
            impl = {"status": "todo"}

        entry["implementation"] = impl
        entry["status"] = impl["status"]  # list_scenarios bunu kullanıyor

        items.append(entry)

    return items


# -------------
# 2) LLM ile mini kullanım kılavuzu üretimi
# -------------

def _build_help_for_entry(entry: Dict[str, Any]) -> Dict[str, Any]:
    """
    Tek bir senaryo için:
    - what_is_tr
    - how_to_tr (list)
    - examples_tr (list)
    alanlarını LLM ile üretir.

    Tamamen Türkçe, Excel bilmeyen ofis çalışanına göre sade anlatım ister.
    """
    title_tr = entry.get("title_tr") or ""
    short_tr = entry.get("short_tr") or ""
    category = entry.get("category") or ""
    sid = entry.get("id")

    system_msg = {
        "role": "system",
        "content": (
            "Sen, Excel'i hiç formül bilmeyen ofis çalışanlarına anlatan, "
            "çok sabırlı ve sade konuşan bir eğitmensin. "
            "opradox adlı bir web uygulaması için senaryo açıklamaları yazıyorsun. "
            "Kullanıcı formül adı, fonksiyon adı bilmek zorunda değil; "
            "sen her şeyi günlük dilde anlatmalısın."
        ),
    }

    user_msg = {
        "role": "user",
        "content": (
            f"Aşağıdaki senaryo için Türkçe mini kullanım kılavuzu hazırla.\n\n"
            f"- Senaryo ID: {sid}\n"
            f"- Kategori (teknik isim): {category}\n"
            f"- Başlık (TR): {title_tr}\n"
            f"- Kısa açıklama (TR): {short_tr}\n\n"
            "İstediğim çıktı formatı JSON olsun. Sadece JSON dön:\n\n"
            "{\n"
            '  \"what_is_tr\": \"Bu senaryo nedir? 1 paragraf.\",\n'
            '  \"how_to_tr\": [\"Adım 1...\", \"Adım 2...\", \"Adım 3...\"],\n'
            '  \"examples_tr\": [\"Örnek 1...\", \"Örnek 2...\", \"Örnek 3...\"]\n"
            "}\n\n"
            "Kurallar:\n"
            "- Excel fonksiyon isimlerini (COUNTIF, SUMIFS vs.) mümkün olduğu kadar az kullan, kullanırsan da parantez içine kısaca yaz.\n"
            "- Kullanıcıyı korkutma; günlük hayattan örnek ver.\n"
            "- Cümleler kısa ve net olsun.\n"
        ),
    }

    raw = llm_client.chat(
        messages=[system_msg, user_msg],
        model=None,           # DEFAULT_SMALL_MODEL kullanılacak
        temperature=0.2,
        max_tokens=800,
    )

    # Bazı durumlarda model tırnak vs. kaçırabilir; bunu tolere etmeye çalışalım
    try:
        data = json.loads(raw)
        if not isinstance(data, dict):
            raise ValueError("JSON dict değil")
    except Exception:
        # Parse edilemezse, en azından temel alanları dolduralım
        data = {
            "what_is_tr": short_tr or f"{title_tr} senaryosu, Excel'de belirli bir analizi kolayca yapmanı sağlar.",
            "how_to_tr": [
                "Excel dosyanı opradox'e yükle.",
                "Sol taraftan ilgili senaryoyu seç.",
                "Senaryonun istediği alanları doldur (sütun, koşul, tarih aralığı vb.).",
                "Senaryoyu çalıştır; sonuçları sağ tarafta özet ve istersen Excel çıktısı olarak gör."
            ],
            "examples_tr": [
                f"{title_tr} senaryosunu, günlük raporlarını daha hızlı hazırlamak için kullanabilirsin."
            ],
        }

    return {
        "what_is_tr": data.get("what_is_tr", "").strip(),
        "how_to_tr": [str(x).strip() for x in data.get("how_to_tr", []) if str(x).strip()],
        "examples_tr": [str(x).strip() for x in data.get("examples_tr", []) if str(x).strip()],
    }


def enrich_catalog_with_help(
    catalog: List[Dict[str, Any]],
    use_llm: bool,
) -> List[Dict[str, Any]]:
    """
    Katalogdaki her senaryoya 'help' alanı ekler.
    use_llm=False ise sadece boş bir template koyar.
    """
    enriched: List[Dict[str, Any]] = []

    for entry in catalog:
        entry = dict(entry)  # kopyala

        if use_llm:
            print(f"[LLM] Senaryo için mini kılavuz üretiliyor: {entry.get('id')}")
            help_tr = _build_help_for_entry(entry)
        else:
            help_tr = {
                "what_is_tr": entry.get("short_tr", "") or "",
                "how_to_tr": [],
                "examples_tr": [],
            }

        entry["help_tr"] = help_tr
        enriched.append(entry)

    return enriched


# -------------
# 3) Katalog kaydetme
# -------------

def save_catalog(catalog: List[Dict[str, Any]]) -> None:
    CONFIG_DIR.mkdir(exist_ok=True)
    CATALOG_PATH.write_text(
        json.dumps(catalog, ensure_ascii=False, indent=2),
        encoding="utf-8",
    )
    print(f"[OK] {len(catalog)} kayıtlı katalog yazıldı -> {CATALOG_PATH}")


def main() -> None:
    parser = argparse.ArgumentParser(description="opradox senaryo kataloğu üretici")
    parser.add_argument(
        "--with-llm",
        action="store_true",
        help="Her senaryo için LLM ile mini kullanım kılavuzu üret",
    )
    args = parser.parse_args()

    print("[INFO] Ham senaryo sayısı (scenario_source.scenarios):", len(RAW_SCENARIOS))

    base_catalog = build_base_catalog()
    print("[INFO] Implementation bağlanmış senaryo sayısı:",
          sum(1 for e in base_catalog if e.get("status") == "implemented"))

    final_catalog = enrich_catalog_with_help(base_catalog, use_llm=args.with_llm)

    save_catalog(final_catalog)


if __name__ == "__main__":
    main()
